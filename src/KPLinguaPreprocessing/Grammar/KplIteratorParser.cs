//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from KplIterator.g4 by ANTLR 4.13.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

namespace KPLinguaPreprocessing.Grammar
{
    [System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.1")]
    [System.CLSCompliant(false)]
    public partial class KplIteratorParser : Antlr4.Runtime.Parser {
        protected static DFA[] decisionToDFA;
        protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
        public const int
            T__0=1, T__1=2, Add=3, Sub=4, Mul=5, Gt=6, Gte=7, Lt=8, Lte=9, Eq=10, 
            Neq=11, Or=12, And=13, Number=14, Identifier=15, WS=16;
        public const int
            RULE_parameters = 0, RULE_parameter = 1, RULE_iterators = 2, RULE_iterator = 3, 
            RULE_arithmeticExpression = 4, RULE_identifier = 5, RULE_relationalExpression = 6, 
            RULE_logicalExpression = 7, RULE_logicalOperator = 8;
        public static readonly string[] ruleNames = {
            "parameters", "parameter", "iterators", "iterator", "arithmeticExpression", 
            "identifier", "relationalExpression", "logicalExpression", "logicalOperator"
        };

        private static readonly string[] _LiteralNames = {
            null, "','", "'='", "'+'", "'-'", "'*'", "'>'", "'>='", "'<'", "'<='", 
            "'=='", "'!='", "'|'", "'&'"
        };
        private static readonly string[] _SymbolicNames = {
            null, null, null, "Add", "Sub", "Mul", "Gt", "Gte", "Lt", "Lte", "Eq", 
            "Neq", "Or", "And", "Number", "Identifier", "WS"
        };
        public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

        [NotNull]
        public override IVocabulary Vocabulary
        {
            get
            {
                return DefaultVocabulary;
            }
        }

        public override string GrammarFileName { get { return "KplIterator.g4"; } }

        public override string[] RuleNames { get { return ruleNames; } }

        public override int[] SerializedAtn { get { return _serializedATN; } }

        static KplIteratorParser() {
            decisionToDFA = new DFA[_ATN.NumberOfDecisions];
            for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
                decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
            }
        }

        public KplIteratorParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

        public KplIteratorParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
            : base(input, output, errorOutput)
        {
            Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
        }

        public partial class ParametersContext : ParserRuleContext {
            [System.Diagnostics.DebuggerNonUserCode] public ParameterContext[] parameter() {
                return GetRuleContexts<ParameterContext>();
            }
            [System.Diagnostics.DebuggerNonUserCode] public ParameterContext parameter(int i) {
                return GetRuleContext<ParameterContext>(i);
            }
            public ParametersContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_parameters; } }
            [System.Diagnostics.DebuggerNonUserCode]
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
                global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult> typedVisitor = visitor as global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitParameters(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public ParametersContext parameters() {
            ParametersContext _localctx = new ParametersContext(Context, State);
            EnterRule(_localctx, 0, RULE_parameters);
            int _la;
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 18;
                    parameter();
                    State = 23;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                    while (_la==T__0) {
                        {
                            {
                                State = 19;
                                Match(T__0);
                                State = 20;
                                parameter();
                            }
                        }
                        State = 25;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                    }
                }
            }
            catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class ParameterContext : ParserRuleContext {
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(KplIteratorParser.Identifier, 0); }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Number() { return GetToken(KplIteratorParser.Number, 0); }
            public ParameterContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_parameter; } }
            [System.Diagnostics.DebuggerNonUserCode]
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
                global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult> typedVisitor = visitor as global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitParameter(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public ParameterContext parameter() {
            ParameterContext _localctx = new ParameterContext(Context, State);
            EnterRule(_localctx, 2, RULE_parameter);
            int _la;
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 26;
                    Match(Identifier);
                    State = 29;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                    if (_la==T__1) {
                        {
                            State = 27;
                            Match(T__1);
                            State = 28;
                            Match(Number);
                        }
                    }

                }
            }
            catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class IteratorsContext : ParserRuleContext {
            public RelationalExpressionContext restrictions;
            [System.Diagnostics.DebuggerNonUserCode] public IteratorContext[] iterator() {
                return GetRuleContexts<IteratorContext>();
            }
            [System.Diagnostics.DebuggerNonUserCode] public IteratorContext iterator(int i) {
                return GetRuleContext<IteratorContext>(i);
            }
            [System.Diagnostics.DebuggerNonUserCode] public RelationalExpressionContext relationalExpression() {
                return GetRuleContext<RelationalExpressionContext>(0);
            }
            public IteratorsContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_iterators; } }
            [System.Diagnostics.DebuggerNonUserCode]
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
                global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult> typedVisitor = visitor as global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitIterators(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public IteratorsContext iterators() {
            IteratorsContext _localctx = new IteratorsContext(Context, State);
            EnterRule(_localctx, 4, RULE_iterators);
            int _la;
            try {
                int _alt;
                EnterOuterAlt(_localctx, 1);
                {
                    State = 31;
                    iterator();
                    State = 36;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream,2,Context);
                    while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
                        if ( _alt==1 ) {
                            {
                                {
                                    State = 32;
                                    Match(T__0);
                                    State = 33;
                                    iterator();
                                }
                            } 
                        }
                        State = 38;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream,2,Context);
                    }
                    State = 41;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                    if (_la==T__0) {
                        {
                            State = 39;
                            Match(T__0);
                            State = 40;
                            _localctx.restrictions = relationalExpression(0);
                        }
                    }

                }
            }
            catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class IteratorContext : ParserRuleContext {
            public ArithmeticExpressionContext left;
            public IToken leftInq;
            public IToken rightInq;
            public ArithmeticExpressionContext right;
            public IToken increment;
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(KplIteratorParser.Identifier, 0); }
            [System.Diagnostics.DebuggerNonUserCode] public ArithmeticExpressionContext[] arithmeticExpression() {
                return GetRuleContexts<ArithmeticExpressionContext>();
            }
            [System.Diagnostics.DebuggerNonUserCode] public ArithmeticExpressionContext arithmeticExpression(int i) {
                return GetRuleContext<ArithmeticExpressionContext>(i);
            }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Lte() { return GetTokens(KplIteratorParser.Lte); }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Lte(int i) {
                return GetToken(KplIteratorParser.Lte, i);
            }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Lt() { return GetTokens(KplIteratorParser.Lt); }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Lt(int i) {
                return GetToken(KplIteratorParser.Lt, i);
            }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Number() { return GetToken(KplIteratorParser.Number, 0); }
            public IteratorContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_iterator; } }
            [System.Diagnostics.DebuggerNonUserCode]
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
                global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult> typedVisitor = visitor as global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitIterator(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public IteratorContext iterator() {
            IteratorContext _localctx = new IteratorContext(Context, State);
            EnterRule(_localctx, 6, RULE_iterator);
            int _la;
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 43;
                    _localctx.left = arithmeticExpression(0);
                    State = 44;
                    _localctx.leftInq = TokenStream.LT(1);
                    _la = TokenStream.LA(1);
                    if ( !(_la==Lt || _la==Lte) ) {
                        _localctx.leftInq = ErrorHandler.RecoverInline(this);
                    }
                    else {
                        ErrorHandler.ReportMatch(this);
                        Consume();
                    }
                    State = 45;
                    Match(Identifier);
                    State = 46;
                    _localctx.rightInq = TokenStream.LT(1);
                    _la = TokenStream.LA(1);
                    if ( !(_la==Lt || _la==Lte) ) {
                        _localctx.rightInq = ErrorHandler.RecoverInline(this);
                    }
                    else {
                        ErrorHandler.ReportMatch(this);
                        Consume();
                    }
                    State = 47;
                    _localctx.right = arithmeticExpression(0);
                    State = 50;
                    ErrorHandler.Sync(this);
                    switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
                        case 1:
                        {
                            State = 48;
                            Match(T__0);
                            State = 49;
                            _localctx.increment = Match(Number);
                        }
                            break;
                    }
                }
            }
            catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class ArithmeticExpressionContext : ParserRuleContext {
            public ArithmeticExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_arithmeticExpression; } }
	 
            public ArithmeticExpressionContext() { }
            public virtual void CopyFrom(ArithmeticExpressionContext context) {
                base.CopyFrom(context);
            }
        }
        public partial class ArOpExpContext : ArithmeticExpressionContext {
            public ArithmeticExpressionContext left;
            public IdentifierContext identifierOp;
            public IToken op;
            public ArithmeticExpressionContext right;
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Number() { return GetToken(KplIteratorParser.Number, 0); }
            [System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
                return GetRuleContext<IdentifierContext>(0);
            }
            [System.Diagnostics.DebuggerNonUserCode] public ArithmeticExpressionContext[] arithmeticExpression() {
                return GetRuleContexts<ArithmeticExpressionContext>();
            }
            [System.Diagnostics.DebuggerNonUserCode] public ArithmeticExpressionContext arithmeticExpression(int i) {
                return GetRuleContext<ArithmeticExpressionContext>(i);
            }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mul() { return GetToken(KplIteratorParser.Mul, 0); }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Add() { return GetToken(KplIteratorParser.Add, 0); }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Sub() { return GetToken(KplIteratorParser.Sub, 0); }
            public ArOpExpContext(ArithmeticExpressionContext context) { CopyFrom(context); }
            [System.Diagnostics.DebuggerNonUserCode]
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
                global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult> typedVisitor = visitor as global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitArOpExp(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public ArithmeticExpressionContext arithmeticExpression() {
            return arithmeticExpression(0);
        }

        private ArithmeticExpressionContext arithmeticExpression(int _p) {
            ParserRuleContext _parentctx = Context;
            int _parentState = State;
            ArithmeticExpressionContext _localctx = new ArithmeticExpressionContext(Context, _parentState);
            ArithmeticExpressionContext _prevctx = _localctx;
            int _startState = 8;
            EnterRecursionRule(_localctx, 8, RULE_arithmeticExpression, _p);
            int _la;
            try {
                int _alt;
                EnterOuterAlt(_localctx, 1);
                {
                    State = 55;
                    ErrorHandler.Sync(this);
                    switch (TokenStream.LA(1)) {
                        case Number:
                        {
                            _localctx = new ArOpExpContext(_localctx);
                            Context = _localctx;
                            _prevctx = _localctx;

                            State = 53;
                            Match(Number);
                        }
                            break;
                        case Identifier:
                        {
                            _localctx = new ArOpExpContext(_localctx);
                            Context = _localctx;
                            _prevctx = _localctx;
                            State = 54;
                            ((ArOpExpContext)_localctx).identifierOp = identifier();
                        }
                            break;
                        default:
                            throw new NoViableAltException(this);
                    }
                    Context.Stop = TokenStream.LT(-1);
                    State = 65;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream,7,Context);
                    while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
                        if ( _alt==1 ) {
                            if ( ParseListeners!=null )
                                TriggerExitRuleEvent();
                            _prevctx = _localctx;
                            {
                                State = 63;
                                ErrorHandler.Sync(this);
                                switch ( Interpreter.AdaptivePredict(TokenStream,6,Context) ) {
                                    case 1:
                                    {
                                        _localctx = new ArOpExpContext(new ArithmeticExpressionContext(_parentctx, _parentState));
                                        ((ArOpExpContext)_localctx).left = _prevctx;
                                        PushNewRecursionContext(_localctx, _startState, RULE_arithmeticExpression);
                                        State = 57;
                                        if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
                                        State = 58;
                                        ((ArOpExpContext)_localctx).op = Match(Mul);
                                        State = 59;
                                        ((ArOpExpContext)_localctx).right = arithmeticExpression(5);
                                    }
                                        break;
                                    case 2:
                                    {
                                        _localctx = new ArOpExpContext(new ArithmeticExpressionContext(_parentctx, _parentState));
                                        ((ArOpExpContext)_localctx).left = _prevctx;
                                        PushNewRecursionContext(_localctx, _startState, RULE_arithmeticExpression);
                                        State = 60;
                                        if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
                                        State = 61;
                                        ((ArOpExpContext)_localctx).op = TokenStream.LT(1);
                                        _la = TokenStream.LA(1);
                                        if ( !(_la==Add || _la==Sub) ) {
                                            ((ArOpExpContext)_localctx).op = ErrorHandler.RecoverInline(this);
                                        }
                                        else {
                                            ErrorHandler.ReportMatch(this);
                                            Consume();
                                        }
                                        State = 62;
                                        ((ArOpExpContext)_localctx).right = arithmeticExpression(4);
                                    }
                                        break;
                                }
                            } 
                        }
                        State = 67;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream,7,Context);
                    }
                }
            }
            catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally {
                UnrollRecursionContexts(_parentctx);
            }
            return _localctx;
        }

        public partial class IdentifierContext : ParserRuleContext {
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(KplIteratorParser.Identifier, 0); }
            public IdentifierContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_identifier; } }
            [System.Diagnostics.DebuggerNonUserCode]
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
                global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult> typedVisitor = visitor as global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitIdentifier(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public IdentifierContext identifier() {
            IdentifierContext _localctx = new IdentifierContext(Context, State);
            EnterRule(_localctx, 10, RULE_identifier);
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 68;
                    Match(Identifier);
                }
            }
            catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class RelationalExpressionContext : ParserRuleContext {
            public RelationalExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_relationalExpression; } }
	 
            public RelationalExpressionContext() { }
            public virtual void CopyFrom(RelationalExpressionContext context) {
                base.CopyFrom(context);
            }
        }
        public partial class LoOpExpContext : RelationalExpressionContext {
            public RelationalExpressionContext left;
            public LogicalExpressionContext lo;
            public IToken op;
            public RelationalExpressionContext right;
            [System.Diagnostics.DebuggerNonUserCode] public LogicalExpressionContext logicalExpression() {
                return GetRuleContext<LogicalExpressionContext>(0);
            }
            [System.Diagnostics.DebuggerNonUserCode] public RelationalExpressionContext[] relationalExpression() {
                return GetRuleContexts<RelationalExpressionContext>();
            }
            [System.Diagnostics.DebuggerNonUserCode] public RelationalExpressionContext relationalExpression(int i) {
                return GetRuleContext<RelationalExpressionContext>(i);
            }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode And() { return GetToken(KplIteratorParser.And, 0); }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Or() { return GetToken(KplIteratorParser.Or, 0); }
            public LoOpExpContext(RelationalExpressionContext context) { CopyFrom(context); }
            [System.Diagnostics.DebuggerNonUserCode]
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
                global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult> typedVisitor = visitor as global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitLoOpExp(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public RelationalExpressionContext relationalExpression() {
            return relationalExpression(0);
        }

        private RelationalExpressionContext relationalExpression(int _p) {
            ParserRuleContext _parentctx = Context;
            int _parentState = State;
            RelationalExpressionContext _localctx = new RelationalExpressionContext(Context, _parentState);
            RelationalExpressionContext _prevctx = _localctx;
            int _startState = 12;
            EnterRecursionRule(_localctx, 12, RULE_relationalExpression, _p);
            try {
                int _alt;
                EnterOuterAlt(_localctx, 1);
                {
                    {
                        _localctx = new LoOpExpContext(_localctx);
                        Context = _localctx;
                        _prevctx = _localctx;

                        State = 71;
                        ((LoOpExpContext)_localctx).lo = logicalExpression();
                    }
                    Context.Stop = TokenStream.LT(-1);
                    State = 81;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
                    while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
                        if ( _alt==1 ) {
                            if ( ParseListeners!=null )
                                TriggerExitRuleEvent();
                            _prevctx = _localctx;
                            {
                                State = 79;
                                ErrorHandler.Sync(this);
                                switch ( Interpreter.AdaptivePredict(TokenStream,8,Context) ) {
                                    case 1:
                                    {
                                        _localctx = new LoOpExpContext(new RelationalExpressionContext(_parentctx, _parentState));
                                        ((LoOpExpContext)_localctx).left = _prevctx;
                                        PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
                                        State = 73;
                                        if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
                                        State = 74;
                                        ((LoOpExpContext)_localctx).op = Match(And);
                                        State = 75;
                                        ((LoOpExpContext)_localctx).right = relationalExpression(4);
                                    }
                                        break;
                                    case 2:
                                    {
                                        _localctx = new LoOpExpContext(new RelationalExpressionContext(_parentctx, _parentState));
                                        ((LoOpExpContext)_localctx).left = _prevctx;
                                        PushNewRecursionContext(_localctx, _startState, RULE_relationalExpression);
                                        State = 76;
                                        if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
                                        State = 77;
                                        ((LoOpExpContext)_localctx).op = Match(Or);
                                        State = 78;
                                        ((LoOpExpContext)_localctx).right = relationalExpression(3);
                                    }
                                        break;
                                }
                            } 
                        }
                        State = 83;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
                    }
                }
            }
            catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally {
                UnrollRecursionContexts(_parentctx);
            }
            return _localctx;
        }

        public partial class LogicalExpressionContext : ParserRuleContext {
            public ArithmeticExpressionContext left;
            public LogicalOperatorContext lo;
            public ArithmeticExpressionContext right;
            [System.Diagnostics.DebuggerNonUserCode] public ArithmeticExpressionContext[] arithmeticExpression() {
                return GetRuleContexts<ArithmeticExpressionContext>();
            }
            [System.Diagnostics.DebuggerNonUserCode] public ArithmeticExpressionContext arithmeticExpression(int i) {
                return GetRuleContext<ArithmeticExpressionContext>(i);
            }
            [System.Diagnostics.DebuggerNonUserCode] public LogicalOperatorContext logicalOperator() {
                return GetRuleContext<LogicalOperatorContext>(0);
            }
            public LogicalExpressionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_logicalExpression; } }
            [System.Diagnostics.DebuggerNonUserCode]
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
                global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult> typedVisitor = visitor as global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitLogicalExpression(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public LogicalExpressionContext logicalExpression() {
            LogicalExpressionContext _localctx = new LogicalExpressionContext(Context, State);
            EnterRule(_localctx, 14, RULE_logicalExpression);
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 84;
                    _localctx.left = arithmeticExpression(0);
                    State = 85;
                    _localctx.lo = logicalOperator();
                    State = 86;
                    _localctx.right = arithmeticExpression(0);
                }
            }
            catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class LogicalOperatorContext : ParserRuleContext {
            public LogicalOperatorContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_logicalOperator; } }
	 
            public LogicalOperatorContext() { }
            public virtual void CopyFrom(LogicalOperatorContext context) {
                base.CopyFrom(context);
            }
        }
        public partial class LogicalOperatorNameContext : LogicalOperatorContext {
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Gt() { return GetToken(KplIteratorParser.Gt, 0); }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Gte() { return GetToken(KplIteratorParser.Gte, 0); }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Lt() { return GetToken(KplIteratorParser.Lt, 0); }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Lte() { return GetToken(KplIteratorParser.Lte, 0); }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eq() { return GetToken(KplIteratorParser.Eq, 0); }
            [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Neq() { return GetToken(KplIteratorParser.Neq, 0); }
            public LogicalOperatorNameContext(LogicalOperatorContext context) { CopyFrom(context); }
            [System.Diagnostics.DebuggerNonUserCode]
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
                global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult> typedVisitor = visitor as global::KPLinguaPreprocessing.Grammar.IKplIteratorVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitLogicalOperatorName(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public LogicalOperatorContext logicalOperator() {
            LogicalOperatorContext _localctx = new LogicalOperatorContext(Context, State);
            EnterRule(_localctx, 16, RULE_logicalOperator);
            try {
                State = 94;
                ErrorHandler.Sync(this);
                switch (TokenStream.LA(1)) {
                    case Gt:
                        _localctx = new LogicalOperatorNameContext(_localctx);
                        EnterOuterAlt(_localctx, 1);
                    {
                        State = 88;
                        Match(Gt);
                    }
                        break;
                    case Gte:
                        _localctx = new LogicalOperatorNameContext(_localctx);
                        EnterOuterAlt(_localctx, 2);
                    {
                        State = 89;
                        Match(Gte);
                    }
                        break;
                    case Lt:
                        _localctx = new LogicalOperatorNameContext(_localctx);
                        EnterOuterAlt(_localctx, 3);
                    {
                        State = 90;
                        Match(Lt);
                    }
                        break;
                    case Lte:
                        _localctx = new LogicalOperatorNameContext(_localctx);
                        EnterOuterAlt(_localctx, 4);
                    {
                        State = 91;
                        Match(Lte);
                    }
                        break;
                    case Eq:
                        _localctx = new LogicalOperatorNameContext(_localctx);
                        EnterOuterAlt(_localctx, 5);
                    {
                        State = 92;
                        Match(Eq);
                    }
                        break;
                    case Neq:
                        _localctx = new LogicalOperatorNameContext(_localctx);
                        EnterOuterAlt(_localctx, 6);
                    {
                        State = 93;
                        Match(Neq);
                    }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
            catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            }
            finally {
                ExitRule();
            }
            return _localctx;
        }

        public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
            switch (ruleIndex) {
                case 4: return arithmeticExpression_sempred((ArithmeticExpressionContext)_localctx, predIndex);
                case 6: return relationalExpression_sempred((RelationalExpressionContext)_localctx, predIndex);
            }
            return true;
        }
        private bool arithmeticExpression_sempred(ArithmeticExpressionContext _localctx, int predIndex) {
            switch (predIndex) {
                case 0: return Precpred(Context, 4);
                case 1: return Precpred(Context, 3);
            }
            return true;
        }
        private bool relationalExpression_sempred(RelationalExpressionContext _localctx, int predIndex) {
            switch (predIndex) {
                case 2: return Precpred(Context, 3);
                case 3: return Precpred(Context, 2);
            }
            return true;
        }

        private static int[] _serializedATN = {
            4,1,16,97,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
            7,7,2,8,7,8,1,0,1,0,1,0,5,0,22,8,0,10,0,12,0,25,9,0,1,1,1,1,1,1,3,1,30,
            8,1,1,2,1,2,1,2,5,2,35,8,2,10,2,12,2,38,9,2,1,2,1,2,3,2,42,8,2,1,3,1,3,
            1,3,1,3,1,3,1,3,1,3,3,3,51,8,3,1,4,1,4,1,4,3,4,56,8,4,1,4,1,4,1,4,1,4,
            1,4,1,4,5,4,64,8,4,10,4,12,4,67,9,4,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,
            6,1,6,1,6,5,6,80,8,6,10,6,12,6,83,9,6,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,
            1,8,1,8,3,8,95,8,8,1,8,0,2,8,12,9,0,2,4,6,8,10,12,14,16,0,2,1,0,8,9,1,
            0,3,4,102,0,18,1,0,0,0,2,26,1,0,0,0,4,31,1,0,0,0,6,43,1,0,0,0,8,55,1,0,
            0,0,10,68,1,0,0,0,12,70,1,0,0,0,14,84,1,0,0,0,16,94,1,0,0,0,18,23,3,2,
            1,0,19,20,5,1,0,0,20,22,3,2,1,0,21,19,1,0,0,0,22,25,1,0,0,0,23,21,1,0,
            0,0,23,24,1,0,0,0,24,1,1,0,0,0,25,23,1,0,0,0,26,29,5,15,0,0,27,28,5,2,
            0,0,28,30,5,14,0,0,29,27,1,0,0,0,29,30,1,0,0,0,30,3,1,0,0,0,31,36,3,6,
            3,0,32,33,5,1,0,0,33,35,3,6,3,0,34,32,1,0,0,0,35,38,1,0,0,0,36,34,1,0,
            0,0,36,37,1,0,0,0,37,41,1,0,0,0,38,36,1,0,0,0,39,40,5,1,0,0,40,42,3,12,
            6,0,41,39,1,0,0,0,41,42,1,0,0,0,42,5,1,0,0,0,43,44,3,8,4,0,44,45,7,0,0,
            0,45,46,5,15,0,0,46,47,7,0,0,0,47,50,3,8,4,0,48,49,5,1,0,0,49,51,5,14,
            0,0,50,48,1,0,0,0,50,51,1,0,0,0,51,7,1,0,0,0,52,53,6,4,-1,0,53,56,5,14,
            0,0,54,56,3,10,5,0,55,52,1,0,0,0,55,54,1,0,0,0,56,65,1,0,0,0,57,58,10,
            4,0,0,58,59,5,5,0,0,59,64,3,8,4,5,60,61,10,3,0,0,61,62,7,1,0,0,62,64,3,
            8,4,4,63,57,1,0,0,0,63,60,1,0,0,0,64,67,1,0,0,0,65,63,1,0,0,0,65,66,1,
            0,0,0,66,9,1,0,0,0,67,65,1,0,0,0,68,69,5,15,0,0,69,11,1,0,0,0,70,71,6,
            6,-1,0,71,72,3,14,7,0,72,81,1,0,0,0,73,74,10,3,0,0,74,75,5,13,0,0,75,80,
            3,12,6,4,76,77,10,2,0,0,77,78,5,12,0,0,78,80,3,12,6,3,79,73,1,0,0,0,79,
            76,1,0,0,0,80,83,1,0,0,0,81,79,1,0,0,0,81,82,1,0,0,0,82,13,1,0,0,0,83,
            81,1,0,0,0,84,85,3,8,4,0,85,86,3,16,8,0,86,87,3,8,4,0,87,15,1,0,0,0,88,
            95,5,6,0,0,89,95,5,7,0,0,90,95,5,8,0,0,91,95,5,9,0,0,92,95,5,10,0,0,93,
            95,5,11,0,0,94,88,1,0,0,0,94,89,1,0,0,0,94,90,1,0,0,0,94,91,1,0,0,0,94,
            92,1,0,0,0,94,93,1,0,0,0,95,17,1,0,0,0,11,23,29,36,41,50,55,63,65,79,81,
            94
        };

        public static readonly ATN _ATN =
            new ATNDeserializer().Deserialize(_serializedATN);


    }
}
